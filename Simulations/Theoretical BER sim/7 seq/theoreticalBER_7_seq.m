N=7; %%number of symbols within a sequenceBER=zeros(15,1); %%bit error rate for awgn channel%%--------------------------------------load('Maps_7.mat');sequences=zeros(3^N, floor(log2(3^N)));for i=1:3^N   if i <= 2^(floor(log2(3^N)))       sequences(i, :) = gray_code(i, :);   else        sequences(i, :) = gray_code(2^(floor(log2(3^N))), :);   endend    %disp(sequences)%disp(0)rgb_sequences = gray_like_combos;%disp(rgb_sequences)%disp(0)hamming_distances=zeros(3^N,3^N); %calculate hamming distances between sequencesdist=0;for i=1:1:3^N  for j=1:1:3^N      for k=1:floor(log2(3^N))        if(sequences(i,k)~=sequences(j,k))            dist=dist+1;        end      end        hamming_distances(i, j)=dist;        dist=0;  endend%disp(hamming_distances);disp(0)%%---------------------------------------------------G = zeros(15, 1);for SNR = 1:15    SNR_lin= 10^(SNR/10);    EsNo = SNR_lin*floor(log2(3^N))*2^(floor(log2(3^N)))/(N*3^N);    fun = @(x)exp(-(0.8*(EsNo)*(sin(pi/3)).^2)./(sin(abs(x-pi/6)+pi/3)).^2) ;    q = integral(fun,pi/6,-pi/2);    q = abs(q/(2*pi));    G(SNR)=q;end%%---------------------------------------------------term=0;p_seq=1;for b=1:1:15  for i=1:1:(2^floor(log2(3^N)))    for j=1:1:3^N      if(j~=i)        for r=1:1:N          if(rgb_sequences(i, r)==rgb_sequences(j, r))            p_seq=p_seq*(1-2*G(b));          else            p_seq=p_seq*G(b);          end                 end      end      term=term+(hamming_distances(i, j)*p_seq);      p_seq=1;           end  end  BER(b)=term;  term=0;end% Zero -----------------------------------------------SNR_lin= 10^(0/10);EsNo = SNR_lin*floor(log2(3^N))*2^(floor(log2(3^N)))/(N*3^N);fun = @(x)exp(-(0.8*(EsNo)*(sin(pi/3)).^2)./(sin(abs(x-pi/6)+pi/3)).^2) ;q = integral(fun,pi/6,-pi/2);q = abs(q/(2*pi));G0=q;term=0;p_seq=1;for i=1:1:(2^floor(log2(3^N)))    for j=1:1:3^N      if(j~=i)        for r=1:1:N          if(rgb_sequences(i, r)==rgb_sequences(j, r))            p_seq=p_seq*(1-2*G0);          else            p_seq=p_seq*G0;          end                 end      end      term=term+(hamming_distances(i, j)*p_seq);      p_seq=1;     endendBER0=term;term=0;BER=[BER0; BER];BER=BER/(floor(log2(3^N))); BER=BER/2^(floor(log2(3^N))); %divide by P(seq_{i})semilogy([0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15], BER, 'r')hold on